import { z } from "zod";
import { router, publicProcedure } from "../trpc";
import { db, purchases } from "db";
import { eq, and, desc, sql } from "drizzle-orm";
import { TRPCError } from "@trpc/server";

export const invoiceNumberRouter = router({
  generate: publicProcedure
    .input(
      z.object({
        vendorId: z.string().uuid(),
        purchaseDate: z.date(),
      }),
    )
    .mutation(async ({ input }) => {
      try {
        return await db.transaction(async (tx) => {
          // Format the date as YYYYMMDD
          const dateStr = input.purchaseDate
            .toISOString()
            .slice(0, 10)
            .replace(/-/g, "");

          // Get the start and end of the day for the purchase date
          const startOfDay = new Date(input.purchaseDate);
          startOfDay.setHours(0, 0, 0, 0);
          const endOfDay = new Date(input.purchaseDate);
          endOfDay.setHours(23, 59, 59, 999);

          // Find the highest sequence number for this vendor and date
          const maxSequenceResult = await tx
            .select({
              maxInvoice: sql<string>`MAX(${purchases.invoiceNumber})`,
            })
            .from(purchases)
            .where(
              and(
                eq(purchases.vendorId, input.vendorId),
                sql`${purchases.purchaseDate} >= ${startOfDay}`,
                sql`${purchases.purchaseDate} <= ${endOfDay}`,
                eq(purchases.autoGeneratedInvoice, true),
                sql`${purchases.invoiceNumber} LIKE ${`${dateStr}-${input.vendorId}-%`}`,
              ),
            );

          // Extract sequence number from the existing invoice numbers
          let nextSequence = 1;

          if (maxSequenceResult[0]?.maxInvoice) {
            // Extract sequence number from format: YYYYMMDD-{vendorId}-{seq}
            // Note: vendorId is a UUID with dashes, so we need to get the last part after the final dash
            const parts = maxSequenceResult[0].maxInvoice.split("-");
            if (parts.length >= 7) {
              // Date + UUID (5 parts) + sequence = 7 parts minimum
              const sequencePart = parts[parts.length - 1];
              const currentSeq = parseInt(sequencePart, 10);
              if (!isNaN(currentSeq)) {
                nextSequence = currentSeq + 1;
              }
            }
          }

          // Generate invoice number with zero-padded sequence
          const paddedSequence = nextSequence.toString().padStart(3, "0");
          const invoiceNumber = `${dateStr}-${input.vendorId}-${paddedSequence}`;

          // Verify uniqueness (additional safety check)
          const existingInvoice = await tx
            .select({ id: purchases.id })
            .from(purchases)
            .where(eq(purchases.invoiceNumber, invoiceNumber))
            .limit(1);

          if (existingInvoice.length > 0) {
            // If there's a conflict, retry with next sequence number
            const retrySequence = (nextSequence + 1)
              .toString()
              .padStart(3, "0");
            const retryInvoiceNumber = `${dateStr}-${input.vendorId}-${retrySequence}`;

            const retryCheck = await tx
              .select({ id: purchases.id })
              .from(purchases)
              .where(eq(purchases.invoiceNumber, retryInvoiceNumber))
              .limit(1);

            if (retryCheck.length > 0) {
              throw new TRPCError({
                code: "CONFLICT",
                message:
                  "Unable to generate unique invoice number due to concurrent requests",
              });
            }

            return {
              invoiceNumber: retryInvoiceNumber,
              sequence: nextSequence + 1,
              datePrefix: dateStr,
            };
          }

          return {
            invoiceNumber,
            sequence: nextSequence,
            datePrefix: dateStr,
          };
        });
      } catch (error) {
        if (error instanceof TRPCError) throw error;
        console.error("Error generating invoice number:", error);
        throw new TRPCError({
          code: "INTERNAL_SERVER_ERROR",
          message: "Failed to generate invoice number",
        });
      }
    }),
});
