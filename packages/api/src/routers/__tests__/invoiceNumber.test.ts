import { describe, it, expect, beforeEach } from 'vitest'
import { createTRPCMsw } from 'msw-trpc'
import { setupServer } from 'msw/node'
import { invoiceNumberRouter } from '../invoiceNumber'
import { db, purchases, vendors } from 'db'
import { eq } from 'drizzle-orm'

// Mock the database
const mockDb = {
  transaction: async (fn: any) => {
    return await fn(mockDb)
  },
  select: () => ({
    from: () => ({
      where: () => ({
        limit: () => Promise.resolve([])
      })
    })
  }),
  insert: () => ({
    values: () => ({
      returning: () => Promise.resolve([{ id: 'test-id' }])
    })
  })
}

// Create test context
const testContext = {
  session: {
    user: {
      id: 'test-user',
      email: 'test@example.com',
      role: 'admin' as const
    }
  }
}

describe('Invoice Number Router', () => {
  const testVendorId = '123e4567-e89b-12d3-a456-426614174000'
  const testDate = new Date('2024-03-15T10:00:00Z')

  beforeEach(async () => {
    // Clean up any test data
    try {
      await db.delete(purchases).where(eq(purchases.vendorId, testVendorId))
    } catch (error) {
      // Ignore cleanup errors in tests
    }
  })

  it('should generate invoice number for new vendor/date combination', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.invoiceNumber).toMatch(/^20240315-123e4567-e89b-12d3-a456-426614174000-001$/)
    expect(result.sequence).toBe(1)
    expect(result.datePrefix).toBe('20240315')
  })

  it('should handle concurrent requests by incrementing sequence numbers', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    // First create a purchase with auto-generated invoice
    await db.insert(purchases).values({
      vendorId: testVendorId,
      purchaseDate: testDate,
      totalCost: '100.00',
      invoiceNumber: `20240315-${testVendorId}-001`,
      autoGeneratedInvoice: true,
      createdAt: new Date(),
      updatedAt: new Date()
    })

    // Now generate next invoice number
    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.invoiceNumber).toMatch(new RegExp(`^20240315-${testVendorId.replace(/[-]/g, '\\-')}-002$`))
    expect(result.sequence).toBe(2)
  })

  it('should handle date boundaries correctly', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    // Create purchase for previous day
    const previousDay = new Date('2024-03-14T23:59:59Z')
    await db.insert(purchases).values({
      vendorId: testVendorId,
      purchaseDate: previousDay,
      totalCost: '100.00',
      invoiceNumber: `20240314-${testVendorId}-001`,
      autoGeneratedInvoice: true,
      createdAt: new Date(),
      updatedAt: new Date()
    })

    // Generate for current day should start at 001
    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.sequence).toBe(1)
    expect(result.datePrefix).toBe('20240315')
  })

  it('should pad sequence numbers with zeros', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    // Create purchases to get to sequence 99
    for (let i = 1; i <= 99; i++) {
      await db.insert(purchases).values({
        vendorId: testVendorId,
        purchaseDate: testDate,
        totalCost: '100.00',
        invoiceNumber: `20240315-${testVendorId}-${i.toString().padStart(3, '0')}`,
        autoGeneratedInvoice: true,
        createdAt: new Date(),
        updatedAt: new Date()
      })
    }

    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.invoiceNumber).toMatch(new RegExp(`^20240315-${testVendorId.replace(/[-]/g, '\\-')}-100$`))
    expect(result.sequence).toBe(100)
  })

  it('should handle different vendors independently', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)
    const vendor2Id = '223e4567-e89b-12d3-a456-426614174000'

    // Create purchase for first vendor
    await db.insert(purchases).values({
      vendorId: testVendorId,
      purchaseDate: testDate,
      totalCost: '100.00',
      invoiceNumber: `20240315-${testVendorId}-005`,
      autoGeneratedInvoice: true,
      createdAt: new Date(),
      updatedAt: new Date()
    })

    // Generate for second vendor should start at 001
    const result = await caller.generate({
      vendorId: vendor2Id,
      purchaseDate: testDate
    })

    expect(result.sequence).toBe(1)
    expect(result.invoiceNumber).toMatch(new RegExp(`^20240315-${vendor2Id.replace(/[-]/g, '\\-')}-001$`))
  })

  it('should handle manual invoice numbers by ignoring them in sequence calculation', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    // Create purchase with manual invoice number (autoGeneratedInvoice: false)
    await db.insert(purchases).values({
      vendorId: testVendorId,
      purchaseDate: testDate,
      totalCost: '100.00',
      invoiceNumber: 'MANUAL-INV-001',
      autoGeneratedInvoice: false,
      createdAt: new Date(),
      updatedAt: new Date()
    })

    // Generate auto invoice should still start at 001
    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.sequence).toBe(1)
    expect(result.invoiceNumber).toMatch(new RegExp(`^20240315-${testVendorId.replace(/[-]/g, '\\-')}-001$`))
  })

  it('should handle retry logic for sequence conflicts', async () => {
    const caller = invoiceNumberRouter.createCaller(testContext)

    // This test would require more complex mocking to simulate race conditions
    // For now, we'll test the basic case
    const result = await caller.generate({
      vendorId: testVendorId,
      purchaseDate: testDate
    })

    expect(result.invoiceNumber).toBeTruthy()
    expect(result.sequence).toBeGreaterThan(0)
    expect(result.datePrefix).toBe('20240315')
  })
})