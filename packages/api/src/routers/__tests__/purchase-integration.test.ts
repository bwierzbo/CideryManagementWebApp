import { describe, it, expect, beforeEach } from "vitest";
import { appRouter } from "..";
import { db, purchases, vendors, appleVarieties } from "db";
import { eq, and } from "drizzle-orm";

// Test context with admin role
const testContext = {
  session: {
    user: {
      id: "test-user-123",
      email: "test@example.com",
      role: "admin" as const,
    },
  },
};

describe("Purchase Router Invoice Number Integration", () => {
  let testVendorId: string;
  let testAppleVarietyId: string;

  beforeEach(async () => {
    // Clean up any existing test data
    await db.delete(purchases);
    await db.delete(vendors);
    await db.delete(appleVarieties);

    // Create test vendor
    const vendor = await db
      .insert(vendors)
      .values({
        name: "Test Vendor Inc",
        contactInfo: { email: "vendor@test.com" },
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();
    testVendorId = vendor[0].id;

    // Create test apple variety
    const variety = await db
      .insert(appleVarieties)
      .values({
        name: "Test Apple",
        description: "Test variety",
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();
    testAppleVarietyId = variety[0].id;
  });

  it("should auto-generate invoice number when not provided", async () => {
    const caller = appRouter.createCaller(testContext);
    const purchaseDate = new Date("2024-03-15T10:00:00Z");

    const result = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      notes: "Test purchase without invoice number",
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 100,
          unit: "kg",
          pricePerUnit: 2.5,
          notes: "Test item",
        },
      ],
    });

    expect(result.success).toBe(true);
    expect(result.purchase.invoiceNumber).toMatch(/^20240315-[\w-]+-001$/);
    expect(result.purchase.autoGeneratedInvoice).toBe(true);
  });

  it("should use provided invoice number when given", async () => {
    const caller = appRouter.createCaller(testContext);
    const purchaseDate = new Date("2024-03-15T10:00:00Z");
    const customInvoice = "CUSTOM-INV-2024-001";

    const result = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      invoiceNumber: customInvoice,
      notes: "Test purchase with custom invoice",
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 50,
          unit: "kg",
          pricePerUnit: 3.0,
          notes: "Custom invoice item",
        },
      ],
    });

    expect(result.success).toBe(true);
    expect(result.purchase.invoiceNumber).toBe(customInvoice);
    expect(result.purchase.autoGeneratedInvoice).toBe(false);
  });

  it("should increment sequence for same vendor and date", async () => {
    const caller = appRouter.createCaller(testContext);
    const purchaseDate = new Date("2024-03-15T10:00:00Z");

    // Create first purchase
    const result1 = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 100,
          unit: "kg",
          pricePerUnit: 2.5,
        },
      ],
    });

    // Create second purchase same day, same vendor
    const result2 = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 75,
          unit: "kg",
          pricePerUnit: 2.75,
        },
      ],
    });

    expect(result1.success).toBe(true);
    expect(result2.success).toBe(true);

    const invoice1 = result1.purchase.invoiceNumber;
    const invoice2 = result2.purchase.invoiceNumber;

    // Both should be auto-generated
    expect(result1.purchase.autoGeneratedInvoice).toBe(true);
    expect(result2.purchase.autoGeneratedInvoice).toBe(true);

    // Should have sequential numbers
    expect(invoice1).toMatch(/^20240315-[\w-]+-001$/);
    expect(invoice2).toMatch(/^20240315-[\w-]+-002$/);

    // Extract and compare sequence numbers
    const seq1 = invoice1!.split("-").pop();
    const seq2 = invoice2!.split("-").pop();
    expect(parseInt(seq2!)).toBe(parseInt(seq1!) + 1);
  });

  it("should handle different dates independently", async () => {
    const caller = appRouter.createCaller(testContext);
    const date1 = new Date("2024-03-15T10:00:00Z");
    const date2 = new Date("2024-03-16T10:00:00Z");

    // Create purchase on first date
    const result1 = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate: date1,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 100,
          unit: "kg",
          pricePerUnit: 2.5,
        },
      ],
    });

    // Create purchase on second date
    const result2 = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate: date2,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 75,
          unit: "kg",
          pricePerUnit: 2.75,
        },
      ],
    });

    expect(result1.success).toBe(true);
    expect(result2.success).toBe(true);

    // Both should start sequence at 001 for their respective dates
    expect(result1.purchase.invoiceNumber).toMatch(/^20240315-[\w-]+-001$/);
    expect(result2.purchase.invoiceNumber).toMatch(/^20240316-[\w-]+-001$/);
  });

  it("should handle multiple vendors on same date", async () => {
    const caller = appRouter.createCaller(testContext);
    const purchaseDate = new Date("2024-03-15T10:00:00Z");

    // Create second vendor
    const vendor2 = await db
      .insert(vendors)
      .values({
        name: "Second Vendor LLC",
        contactInfo: { email: "vendor2@test.com" },
        createdAt: new Date(),
        updatedAt: new Date(),
      })
      .returning();
    const vendor2Id = vendor2[0].id;

    // Create purchases for both vendors same date
    const result1 = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 100,
          unit: "kg",
          pricePerUnit: 2.5,
        },
      ],
    });

    const result2 = await caller.purchase.create({
      vendorId: vendor2Id,
      purchaseDate,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 75,
          unit: "kg",
          pricePerUnit: 2.75,
        },
      ],
    });

    expect(result1.success).toBe(true);
    expect(result2.success).toBe(true);

    // Both should have sequence 001 for their respective vendors
    expect(result1.purchase.invoiceNumber).toMatch(
      new RegExp(`^20240315-${testVendorId.replace(/[-]/g, "\\-")}-001$`),
    );
    expect(result2.purchase.invoiceNumber).toMatch(
      new RegExp(`^20240315-${vendor2Id.replace(/[-]/g, "\\-")}-001$`),
    );
  });

  it("should preserve total cost calculation with auto-generated invoices", async () => {
    const caller = appRouter.createCaller(testContext);
    const purchaseDate = new Date("2024-03-15T10:00:00Z");

    const result = await caller.purchase.create({
      vendorId: testVendorId,
      purchaseDate,
      items: [
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 100,
          unit: "kg",
          pricePerUnit: 2.5,
        },
        {
          appleVarietyId: testAppleVarietyId,
          quantity: 50,
          unit: "kg",
          pricePerUnit: 3.0,
        },
      ],
    });

    expect(result.success).toBe(true);
    expect(result.purchase.invoiceNumber).toMatch(/^20240315-[\w-]+-001$/);
    expect(result.purchase.autoGeneratedInvoice).toBe(true);

    // Total should be (100 * 2.50) + (50 * 3.00) = 400.00
    expect(parseFloat(result.purchase.totalCost)).toBe(400.0);
    expect(result.items.length).toBe(2);
  });

  describe("Free Apple Purchase Scenarios", () => {
    it("should handle purchase with null pricePerUnit (free apples)", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      const result = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        notes: "Free apples from farmer friend",
        items: [
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 500,
            unit: "kg",
            // pricePerUnit omitted for free apples
            notes: "Free donation from neighbor orchard",
          },
        ],
      });

      expect(result.success).toBe(true);
      expect(result.purchase.invoiceNumber).toMatch(/^20240315-[\w-]+-001$/);
      expect(result.purchase.autoGeneratedInvoice).toBe(true);
      expect(parseFloat(result.purchase.totalCost)).toBe(0.0);
      expect(result.items.length).toBe(1);
      expect(result.items[0].pricePerUnit).toBeNull();
      expect(result.items[0].totalCost).toBeNull();
    });

    it("should handle mixed free and paid apples in same purchase", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      const result = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        notes: "Mixed purchase - some free, some paid",
        items: [
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 300,
            unit: "kg",
            pricePerUnit: 2.0,
            notes: "Premium paid apples",
          },
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 200,
            unit: "kg",
            // pricePerUnit omitted for free apples
            notes: "Free seconds/drops",
          },
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 100,
            unit: "kg",
            pricePerUnit: 1.5,
            notes: "Bulk rate paid apples",
          },
        ],
      });

      expect(result.success).toBe(true);
      expect(result.purchase.autoGeneratedInvoice).toBe(true);

      // Total should be: (300 * 2.00) + 0 + (100 * 1.50) = 600 + 0 + 150 = 750
      expect(parseFloat(result.purchase.totalCost)).toBe(750.0);
      expect(result.items.length).toBe(3);

      // Check individual items
      const paidItem1 = result.items.find(
        (item) => parseFloat(item.pricePerUnit || "0") === 2.0,
      );
      const freeItem = result.items.find((item) => item.pricePerUnit === null);
      const paidItem2 = result.items.find(
        (item) => parseFloat(item.pricePerUnit || "0") === 1.5,
      );

      expect(paidItem1).toBeDefined();
      expect(paidItem1?.totalCost).toBe("600.00");

      expect(freeItem).toBeDefined();
      expect(freeItem?.pricePerUnit).toBeNull();
      expect(freeItem?.totalCost).toBeNull();

      expect(paidItem2).toBeDefined();
      expect(paidItem2?.totalCost).toBe("150.00");
    });

    it("should handle multiple free apple purchases from same vendor", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      // First free purchase
      const result1 = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        notes: "First free apple delivery",
        items: [
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 150,
            unit: "kg",
            notes: "Morning pickup - free",
          },
        ],
      });

      // Second free purchase same day
      const result2 = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        notes: "Second free apple delivery",
        items: [
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 200,
            unit: "kg",
            notes: "Afternoon pickup - free",
          },
        ],
      });

      expect(result1.success).toBe(true);
      expect(result2.success).toBe(true);

      // Both should have $0 total cost
      expect(parseFloat(result1.purchase.totalCost)).toBe(0.0);
      expect(parseFloat(result2.purchase.totalCost)).toBe(0.0);

      // Should have sequential invoice numbers
      const invoice1 = result1.purchase.invoiceNumber!;
      const invoice2 = result2.purchase.invoiceNumber!;

      expect(invoice1).toMatch(/^20240315-[\w-]+-001$/);
      expect(invoice2).toMatch(/^20240315-[\w-]+-002$/);

      // Both should be auto-generated
      expect(result1.purchase.autoGeneratedInvoice).toBe(true);
      expect(result2.purchase.autoGeneratedInvoice).toBe(true);
    });

    it("should preserve cost calculation accuracy with free items", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      const result = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        items: [
          // High-precision decimal test
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 123.456,
            unit: "kg",
            pricePerUnit: 2.3333,
            notes: "Precision test paid",
          },
          // Large quantity free apples
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 1000,
            unit: "kg",
            notes: "Large free donation",
          },
          // Small paid quantity
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 0.5,
            unit: "kg",
            pricePerUnit: 5.0,
            notes: "Small premium sample",
          },
        ],
      });

      expect(result.success).toBe(true);

      // Total should be: (123.456 * 2.3333) + 0 + (0.5 * 5.00) = 288.067... + 0 + 2.5 ≈ 290.57
      const expectedTotal = 123.456 * 2.3333 + 0.5 * 5.0;
      expect(parseFloat(result.purchase.totalCost)).toBeCloseTo(
        expectedTotal,
        2,
      );

      expect(result.items.length).toBe(3);

      // Free item should have null values
      const freeItem = result.items.find(
        (item) => parseFloat(item.quantity) === 1000,
      );
      expect(freeItem?.pricePerUnit).toBeNull();
      expect(freeItem?.totalCost).toBeNull();
    });

    it("should handle zero quantity edge case gracefully", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      // This should fail validation since quantity must be positive
      await expect(
        caller.purchase.create({
          vendorId: testVendorId,
          purchaseDate,
          items: [
            {
              appleVarietyId: testAppleVarietyId,
              quantity: 0,
              unit: "kg",
              pricePerUnit: 2.0,
            },
          ],
        }),
      ).rejects.toThrow();
    });

    it("should store canonical weight conversions for free apples", async () => {
      const caller = appRouter.createCaller(testContext);
      const purchaseDate = new Date("2024-03-15T10:00:00Z");

      const result = await caller.purchase.create({
        vendorId: testVendorId,
        purchaseDate,
        items: [
          {
            appleVarietyId: testAppleVarietyId,
            quantity: 1000,
            unit: "lb", // Free apples measured in pounds
            notes: "Free apples measured in pounds",
          },
        ],
      });

      expect(result.success).toBe(true);
      expect(result.items.length).toBe(1);

      const item = result.items[0];
      expect(item.unit).toBe("lb"); // Original unit preserved
      expect(item.pricePerUnit).toBeNull();
      expect(item.totalCost).toBeNull();

      // Should have canonical kg conversion: 1000 lb * 0.453592 ≈ 453.592 kg
      expect(parseFloat(item.quantityKg!)).toBeCloseTo(453.592, 2);
      expect(item.quantityL).toBeNull(); // Volume should be null for weight units
    });
  });
});
