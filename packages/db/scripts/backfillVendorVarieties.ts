#!/usr/bin/env tsx

import "dotenv/config";
import { db } from "../src/client";
import { purchases, purchaseItems, vendorVarieties } from "../src/schema";
import { sql } from "drizzle-orm";

/**
 * Backfill vendor_varieties from existing purchase_items data
 * This populates the vendor_varieties join table based on which varieties each vendor has sold
 *
 * This script is idempotent and safe to run multiple times in production.
 * It uses ON CONFLICT DO NOTHING to avoid creating duplicate records.
 */
async function backfillVendorVarieties() {
  console.log("ðŸ”„ Starting vendor_varieties backfill...");

  try {
    // First, check current state
    const currentCountResult = await db.execute(sql`
      SELECT COUNT(*) as total FROM vendor_varieties
    `);
    const currentCount = currentCountResult.rows[0]?.total || 0;
    console.log(`ðŸ“Š Current vendor-variety relationships: ${currentCount}`);

    // Insert vendor-variety relationships based on existing purchase data
    // Use DISTINCT to avoid duplicates if a vendor has sold the same variety multiple times
    const result = await db.execute(sql`
      INSERT INTO vendor_varieties (vendor_id, variety_id, notes, created_at, updated_at)
      SELECT DISTINCT
          p.vendor_id,
          pi.apple_variety_id,
          'Auto-generated from existing purchase data' as notes,
          NOW() as created_at,
          NOW() as updated_at
      FROM purchases p
      INNER JOIN purchase_items pi ON p.id = pi.purchase_id
      WHERE p.vendor_id IS NOT NULL
        AND pi.apple_variety_id IS NOT NULL
        AND p.deleted_at IS NULL
        AND pi.deleted_at IS NULL
      ON CONFLICT (vendor_id, variety_id) DO NOTHING
    `);

    console.log(
      `âœ… Backfill completed. SQL rows affected: ${result.rowCount || 0}`,
    );

    // Count the total relationships after backfill
    const newCountResult = await db.execute(sql`
      SELECT COUNT(*) as total FROM vendor_varieties
    `);
    const newCount = newCountResult.rows[0]?.total || 0;
    const added = Number(newCount) - Number(currentCount);

    console.log(
      `ðŸ“Š Total vendor-variety relationships after backfill: ${newCount}`,
    );
    console.log(`âž• New relationships added: ${added}`);

    // Count auto-generated vs manually created
    const autoGeneratedResult = await db.execute(sql`
      SELECT COUNT(*) as total
      FROM vendor_varieties
      WHERE notes = 'Auto-generated from existing purchase data'
    `);
    const autoGenerated = autoGeneratedResult.rows[0]?.total || 0;
    const manual = Number(newCount) - Number(autoGenerated);

    console.log(`ðŸ¤– Auto-generated relationships: ${autoGenerated}`);
    console.log(`ðŸ‘¤ Manually created relationships: ${manual}`);

    // Show some sample data if any relationships exist
    if (Number(newCount) > 0) {
      const sampleResult = await db.execute(sql`
        SELECT
          v.name as vendor_name,
          av.name as variety_name,
          vv.notes,
          vv.created_at
        FROM vendor_varieties vv
        JOIN vendors v ON vv.vendor_id = v.id
        JOIN apple_varieties av ON vv.variety_id = av.id
        ORDER BY vv.created_at DESC
        LIMIT 5
      `);

      console.log("\nðŸ“‹ Sample vendor-variety relationships:");
      for (const row of sampleResult.rows) {
        const isAutoGenerated =
          row.notes === "Auto-generated from existing purchase data";
        const icon = isAutoGenerated ? "ðŸ¤–" : "ðŸ‘¤";
        console.log(`  ${icon} ${row.vendor_name} â†’ ${row.variety_name}`);
      }
    }
  } catch (error) {
    console.error("âŒ Error during backfill:", error);
    throw error;
  }
}

// Run the backfill if this script is executed directly
if (require.main === module) {
  backfillVendorVarieties()
    .then(() => {
      console.log("\nâœ¨ Backfill completed successfully!");
      process.exit(0);
    })
    .catch((error) => {
      console.error("\nðŸ’¥ Backfill failed:", error);
      process.exit(1);
    });
}

export { backfillVendorVarieties };
