---
name: Purchase Line Integration
status: open
created: 2025-09-14T05:42:42Z
updated: 2025-09-14T05:58:51Z
github: https://github.com/bwierzbo/CideryManagementWebApp/issues/23
depends_on: [30]
parallel: true
conflicts_with: []
---

# Purchase Line Integration

## Description

Implement purchase line integration for press run workflow, providing inventory validation and apple variety selection based on available purchase lines. The system will restrict apple selection to only those varieties that are available from purchase lines, handle vendor-specific filtering, and enforce inventory constraints to prevent over-allocation of purchased fruit.

## Acceptance Criteria

- [ ] `purchaseLine.available` endpoint returns pressable inventory filtered by vendor
- [ ] Apple variety selection restricted to varieties with available purchase lines
- [ ] Inventory constraints prevent over-allocation of purchased fruit
- [ ] Vendor-specific filtering shows only relevant purchase lines
- [ ] Weight tracking maintains accurate available quantities
- [ ] Integration with existing purchase line schema without modifications
- [ ] Support for multiple units (lbs/kg) with proper conversion
- [ ] Efficient querying with appropriate database indexing
- [ ] Real-time inventory updates as press runs consume purchase lines
- [ ] Validation prevents negative inventory scenarios

## Technical Details

### Core Endpoint Implementation
**`purchaseLine.available`** - Get pressable inventory
- Input: vendorId (optional), appleVarietyId (optional), limit/offset for pagination
- RBAC: 'list', 'purchaseLine' (admin/operator)
- Logic: Calculate available quantities from purchase lines minus already consumed amounts
- Returns: Available purchase lines with remaining quantities and variety details

### Inventory Calculation Logic
```typescript
// Calculate available quantity for each purchase line
availableQuantity = purchaseLine.quantity - SUM(pressRunLoad.weightKg WHERE purchaseLineId = purchaseLine.id)

// Filter only positive availability
WHERE availableQuantity > 0

// Join with apple variety data for selection UI
JOIN appleVarieties ON purchaseLine.appleVarietyId = appleVarieties.id
```

### Vendor Filtering
- Filter purchase lines by vendor when vendorId provided
- Support "All Vendors" option for mixed press runs
- Maintain vendor association for cost tracking and COGS

### Data Validation
- Validate purchase line availability before allowing press run load creation
- Check quantity constraints in real-time during load entry
- Handle concurrent access scenarios with proper locking
- Prevent partial consumption of purchase lines below minimum thresholds

### Integration Points
- Purchase lines table for inventory queries
- Apple varieties for selection options
- Press run loads for consumption tracking
- Vendors for filtering and cost association

### Performance Considerations
- Index on purchase_lines(vendor_id, apple_variety_id, quantity)
- Efficient aggregation queries for availability calculation
- Caching layer for frequently accessed variety/vendor combinations
- Pagination for large purchase line datasets

## Dependencies

- Task 002: Database migration must include press_run_loads table for consumption tracking
- Existing purchase line and apple variety schemas
- RBAC permissions for purchase line access

## Effort Estimate

**Medium (M) - 16 hours**

### Breakdown:
- Available inventory endpoint implementation: 6 hours
- Vendor and variety filtering logic: 4 hours
- Inventory constraint validation: 3 hours
- Performance optimization and indexing: 2 hours
- Unit tests for inventory calculations: 1 hour

### Parallel Execution:
Can be developed simultaneously with task 003 (tRPC Press Run Router) as they integrate at the validation layer.

## Definition of Done

- [ ] `purchaseLine.available` endpoint returns accurate available quantities
- [ ] Vendor filtering correctly restricts purchase lines by vendor relationship
- [ ] Apple variety selection only shows varieties with available inventory
- [ ] Inventory constraints prevent over-allocation in all scenarios
- [ ] Database queries optimized with appropriate indexes
- [ ] Unit tests cover edge cases like zero inventory and concurrent access
- [ ] Integration tests validate end-to-end inventory flow
- [ ] Performance testing confirms sub-second response for inventory queries
- [ ] Documentation includes inventory calculation methodology
- [ ] Error handling provides clear feedback for inventory shortage scenarios