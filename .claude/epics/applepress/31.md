---
name: tRPC Press Run Router
status: open
created: 2025-09-14T05:42:42Z
updated: 2025-09-14T05:58:51Z
github: https://github.com/bwierzbo/CideryManagementWebApp/issues/31
depends_on: [30]
parallel: true
conflicts_with: []
---

# tRPC Press Run Router

## Description

Implement a complete tRPC router for press run operations following established patterns from the vendor and purchasing modules. The router will provide endpoints for creating press runs, adding fruit loads, completing runs, and querying press run data. All operations include proper RBAC permissions, validation, and audit logging integration.

## Acceptance Criteria

- [ ] `pressRun.create` endpoint initializes new press run with vendor selection
- [ ] `pressRun.addLoad` endpoint adds fruit loads with immediate persistence
- [ ] `pressRun.finish` endpoint completes runs with juice volume and vessel assignment
- [ ] `pressRun.list` endpoint returns resumable and completed runs with pagination
- [ ] `pressRun.get` endpoint retrieves specific run with all associated loads
- [ ] All endpoints follow existing RBAC patterns with appropriate permissions
- [ ] Comprehensive input validation using Zod schemas
- [ ] Proper error handling with meaningful TRPCError responses
- [ ] Integration with audit logging system for all operations
- [ ] Support for optimistic updates and offline capability
- [ ] Unit tests covering all endpoints and error scenarios

## Technical Details

### Router Structure
Follow patterns from `packages/api/src/routers/vendor.ts`:
- Use `createRbacProcedure` for all endpoints with appropriate permissions
- Implement comprehensive Zod validation schemas
- Include proper error handling with TRPCError
- Integrate audit logging through eventBus pattern

### Key Endpoints
1. **pressRun.create** - Initialize new press run
   - Input: vendorId, startTime (optional), notes (optional)
   - RBAC: 'create', 'pressRun' (admin/operator)
   - Returns: new press run with ID for subsequent operations

2. **pressRun.addLoad** - Add fruit load to existing run
   - Input: pressRunId, purchaseLineId, appleVarietyId, weightKg, weightUnitEntered
   - RBAC: 'update', 'pressRun' (admin/operator)
   - Validation: purchase line availability, weight constraints
   - Returns: updated press run with new load

3. **pressRun.finish** - Complete press run
   - Input: pressRunId, juiceVolumeL, vesselId, laborHours, workerCount, notes
   - RBAC: 'update', 'pressRun' (admin/operator)
   - Validation: vessel availability, positive juice volume
   - Returns: completed press run summary

4. **pressRun.list** - Query press runs
   - Input: status filter, vendor filter, pagination parameters
   - RBAC: 'list', 'pressRun' (admin/operator/viewer)
   - Returns: paginated press runs with summary data

5. **pressRun.get** - Get specific press run
   - Input: pressRunId
   - RBAC: 'read', 'pressRun' (admin/operator/viewer)
   - Returns: complete press run with loads and related data

### Integration Points
- Purchase line validation for inventory constraints
- Vessel availability checking
- Apple variety reference data
- Audit logging for all state changes
- Error handling for concurrent modifications

## Dependencies

- Task 002: Database migration for press run tables must be completed
- Existing RBAC system and permissions structure
- Purchase line and vessel schemas for validation
- Audit logging infrastructure

## Effort Estimate

**Large (L) - 32 hours**

### Breakdown:
- Router setup and basic CRUD endpoints: 12 hours
- Business logic validation and constraints: 8 hours
- Audit logging integration: 4 hours
- Error handling and edge cases: 4 hours
- Unit tests and integration tests: 4 hours

### Parallel Execution:
Can be developed in parallel with task 004 (Purchase Line Integration) as they use independent validation logic.

## Definition of Done

- [ ] All endpoints implemented with proper TypeScript types
- [ ] Zod validation schemas cover all input parameters
- [ ] RBAC permissions correctly restrict access by role
- [ ] Audit logging captures all press run state changes
- [ ] Comprehensive error handling for all failure scenarios
- [ ] Unit tests achieve 100% coverage of router logic
- [ ] Integration tests validate end-to-end press run workflow
- [ ] Code review approved focusing on security and performance
- [ ] Documentation updated with API endpoint specifications
- [ ] Performance testing confirms sub-second response times for all operations