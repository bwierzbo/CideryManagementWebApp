# Invoice Number Auto-Generation Implementation

## Overview
Implemented unique daily sequence generation per vendor using format `YYYYMMDD-{vendorId}-{seq}` as specified in Task 004.

## Implementation Details

### 1. Database Schema
The existing schema already included the required fields:
- `purchases.invoiceNumber`: text field for storing the generated invoice number
- `purchases.autoGeneratedInvoice`: boolean field to track if the invoice was auto-generated

### 2. New tRPC Router: `/packages/api/src/routers/invoiceNumber.ts`

**Features:**
- `generate` mutation that creates unique invoice numbers
- Format: `YYYYMMDD-{vendorId}-{seq}` (e.g., `20240315-123e4567-e89b-12d3-a456-426614174000-001`)
- Handles concurrent requests safely using database transactions
- Sequence starts at 001 and increments per vendor per day
- Retry logic for handling race conditions

**Key Implementation Points:**
- Uses database transactions for atomicity
- Queries existing invoices with `MAX()` to find highest sequence
- Properly handles UUID format in parsing (7 parts when split by dash)
- Zero-padded sequence numbers (001, 002, etc.)
- Validates uniqueness before returning result

### 3. Purchase Router Integration: `/packages/api/src/routers/index.ts`

**Enhanced purchase.create mutation:**
- Auto-generates invoice numbers when not provided by user
- Sets `autoGeneratedInvoice: true` for auto-generated numbers
- Sets `autoGeneratedInvoice: false` for manually provided invoices
- Maintains backwards compatibility with existing invoice number input
- Uses same logic as dedicated invoice number router for consistency

### 4. Main Router Registration
Added `invoiceNumber` router to the main `appRouter` in `/packages/api/src/routers/index.ts`.

### 5. Test Coverage
Created comprehensive tests in:
- `/packages/api/src/routers/__tests__/invoice-generation.test.ts` - Logic validation
- `/packages/api/src/routers/__tests__/invoiceNumber.test.ts` - Router testing
- `/packages/api/src/routers/__tests__/purchase-integration.test.ts` - Integration testing

**Test Scenarios Covered:**
- Basic invoice number generation
- Sequence incrementing for same vendor/date
- Date boundary handling (different days start at 001)
- Multiple vendors on same date (independent sequences)
- Manual vs auto-generated invoice handling
- Edge cases and malformed data
- Concurrent request simulation

## Technical Guarantees

### Uniqueness
- Database-level uniqueness enforced through transaction isolation
- Vendor + date combination creates independent sequence counters
- Conflict detection with retry logic (limited retries to prevent infinite loops)

### Race Condition Handling
- All operations wrapped in database transactions
- MAX() query ensures latest sequence number discovery
- Immediate uniqueness verification before commit
- Fallback retry logic with incremented sequence

### Format Consistency
- Standardized date format: `YYYYMMDD`
- UUID preservation in vendor ID part
- Zero-padded sequence: `001`, `002`, etc.
- Delimiter consistency with dashes

## Usage Examples

### Auto-generation (recommended)
```typescript
// Purchase creation without invoice number
const purchase = await api.purchase.create({
  vendorId: "123e4567-e89b-12d3-a456-426614174000",
  purchaseDate: new Date("2024-03-15"),
  items: [/* ... */]
})
// Result: invoiceNumber = "20240315-123e4567-e89b-12d3-a456-426614174000-001"
// autoGeneratedInvoice = true
```

### Manual invoice (backward compatibility)
```typescript
// Purchase creation with custom invoice number
const purchase = await api.purchase.create({
  vendorId: "123e4567-e89b-12d3-a456-426614174000",
  purchaseDate: new Date("2024-03-15"),
  invoiceNumber: "CUSTOM-INV-2024-001",
  items: [/* ... */]
})
// Result: invoiceNumber = "CUSTOM-INV-2024-001"
// autoGeneratedInvoice = false
```

### Direct generation (if needed)
```typescript
// Direct invoice number generation
const result = await api.invoiceNumber.generate({
  vendorId: "123e4567-e89b-12d3-a456-426614174000",
  purchaseDate: new Date("2024-03-15")
})
// Result: { invoiceNumber: "20240315-123e4567-e89b-12d3-a456-426614174000-001", sequence: 1, datePrefix: "20240315" }
```

## Security & Performance

### Security
- Input validation through Zod schemas
- UUID format validation for vendor IDs
- SQL injection protection through parameterized queries
- Transaction isolation prevents data corruption

### Performance
- Efficient MAX() query with proper indexing strategy
- Minimal database round trips (single transaction)
- No unnecessary data retrieval (only sequence calculation)
- Designed for high-concurrency scenarios

## Future Considerations

1. **Database Indexing**: Consider adding composite index on `(vendorId, purchaseDate, autoGeneratedInvoice)` for optimal query performance
2. **Sequence Limits**: Current implementation supports 999 invoices per vendor per day (sequence 001-999)
3. **Audit Trail**: All invoice generation is logged through existing audit system
4. **Timezone Handling**: Uses server timezone for date boundaries; consider UTC normalization if needed

## Deployment Notes

- Backward compatible - existing manual invoice numbers remain unchanged
- New purchases without invoice numbers automatically get generated numbers
- No database migrations required (schema already supports the fields)
- Safe to deploy without disrupting existing functionality

## Error Handling

- **Validation Errors**: Invalid UUIDs, dates, etc. return clear error messages
- **Conflict Resolution**: Automatic retry with incremented sequence
- **Transaction Failures**: Proper rollback with informative error responses
- **Database Connectivity**: Graceful failure with retry suggestions